<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ•ÿØÿßÿ±ÿ©</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=yes, minimum-scale=1, maximum-scale=5">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <!-- Bootstrap CSS (CDN) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined" rel="stylesheet">
    <style>
        body {
            background: #f4f6fb;
            font-family: 'Segoe UI', 'Cairo', Tahoma, Geneva, Verdana, sans-serif;
        }
        .sidebar {
            min-height: 100vh;
            background: #fff;
            border-left: 1px solid #e5e7eb;
            box-shadow: -2px 0 8px 0 rgba(0,0,0,0.03);
            padding-top: 2rem;
        }
        .sidebar .nav-link {
            color: #222;
            border-radius: 8px;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1.05rem;
            transition: background 0.15s, color 0.15s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
        }
        .sidebar .nav-link.active, .sidebar .nav-link:hover {
            background: #f0f4fa;
            color: #1976d2;
        }
        .sidebar .material-icons-outlined {
            font-size: 1.5rem;
            margin-left: 8px;
            color: #1976d2;
        }
        .content-area {
            padding: 2.5rem 3rem;
        }
        .navbar {
            background: #fff;
            border-bottom: 1px solid #e5e7eb;
            box-shadow: 0 2px 8px 0 rgba(0,0,0,0.03);
        }
        .navbar-brand {
            font-weight: bold;
            color: #1976d2 !important;
            font-size: 1.4rem;
            letter-spacing: 1px;
        }
        .section {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 2px 8px 0 rgba(0,0,0,0.04);
            padding: 2rem 2.5rem;
            margin-bottom: 2rem;
            min-height: 350px;
            transition: box-shadow 0.2s;
        }
        .section h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #1976d2;
            margin-bottom: 1.5rem;
        }
        .alert-info {
            background: #e3f0fc;
            color: #1976d2;
            border: none;
            border-radius: 8px;
        }
        
        /* Mobile Navigation - Simplified and Reliable */
        .mobile-nav {
            display: none;
            background: #fff;
            border-bottom: 3px solid #1976d2;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 1rem 1.5rem;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 2000;
            justify-content: space-between;
            align-items: center;
            width: 100vw;
        }
        
        .mobile-nav h5 {
            color: #1976d2;
            font-weight: 700;
            margin: 0;
            font-size: 1.3rem;
        }
        
        .mobile-menu-btn {
            background: #1976d2;
            border: none;
            font-size: 1.8rem;
            color: white;
            cursor: pointer;
            padding: 0.75rem;
            border-radius: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 52px;
            min-height: 52px;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.3);
        }
        
        .mobile-menu-btn:hover {
            background-color: #1565c0;
            transform: scale(1.05);
        }
        
        .mobile-nav-menu {
            display: none;
            position: fixed;
            top: 80px;
            left: 0;
            right: 0;
            background: #fff;
            border-top: 1px solid #e5e7eb;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 1999;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }
        
        .mobile-nav-menu.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .mobile-nav-menu .nav-link {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #f1f1f1;
            color: #222;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 1rem;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 1rem;
            min-height: 60px;
        }
        
        .mobile-nav-menu .nav-link:last-child {
            border-bottom: none;
        }
        
        .mobile-nav-menu .nav-link:hover,
        .mobile-nav-menu .nav-link.active {
            background: #f0f4fa;
            color: #1976d2;
            padding-right: 2rem;
        }
        
        .mobile-nav-menu .material-icons-outlined {
            color: #1976d2;
            font-size: 1.4rem;
            min-width: 24px;
        }
        
        /* CRITICAL: Force mobile nav visibility on small screens */
        @media (max-width: 991.98px) {
            .sidebar { 
                display: none !important; 
            }
            .content-area { 
                padding: 0;
                margin: 0;
            }
            .mobile-nav {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            #contentFrame {
                height: calc(100vh - 80px) !important;
                border-radius: 0;
                margin-top: 80px;
            }
            .container-fluid {
                padding-top: 0 !important;
                margin-top: 0 !important;
            }
            body {
                padding-top: 0;
                margin-top: 0;
            }
        }
        
        /* Desktop sidebar visibility */
        @media (min-width: 992px) {
            .mobile-nav {
                display: none !important;
            }
            .sidebar {
                display: block !important;
            }
        }
        
        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .mobile-nav {
                padding: 1rem;
            }
            .mobile-nav h5 {
                font-size: 1.1rem;
            }
            .mobile-menu-btn {
                font-size: 1.6rem;
                min-width: 48px;
                min-height: 48px;
            }
            .mobile-nav-menu .nav-link {
                min-height: 56px;
                font-size: 1.1rem;
            }
        }
        
        @media (max-width: 576px) {
            .mobile-nav {
                padding: 0.75rem 1rem;
            }
            .mobile-nav h5 {
                font-size: 1rem;
            }
            .mobile-nav-menu .nav-link {
                padding: 1rem;
                font-size: 0.95rem;
            }
            .mobile-menu-btn {
                font-size: 1.5rem;
                min-width: 44px;
                min-height: 44px;
            }
        }
        
        /* Enhanced iframe responsiveness */
        #contentFrame {
            width: 100%;
            border: none;
            background: #f4f6fb;
        }
        
        /* Touch-friendly interactions */
        @media (hover: none) {
            .nav-link:hover,
            .mobile-nav-menu .nav-link:hover {
                background: inherit;
            }
            
            .nav-link:active,
            .mobile-nav-menu .nav-link:active {
                background: #f0f4fa;
                transform: scale(0.98);
            }
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Focus states for keyboard navigation */
        .nav-link:focus,
        .mobile-menu-btn:focus {
            outline: 2px solid #1976d2;
            outline-offset: 2px;
        }
        
        /* Loading state for iframe */
        #contentFrame {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        #contentFrame.loading {
            opacity: 0.7;
        }
        
        /* Scroll behavior */
        html {
            scroll-behavior: smooth;
        }
        
        /* Prevent horizontal scroll */
        body {
            overflow-x: hidden;
        }
    </style>
</head>
<body>
    <!-- Mobile Navigation -->
    <div class="mobile-nav" id="mobileNavBar">
        <h5 class="mb-0">üè† ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ</h5>
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ™ŸÜŸÇŸÑ">
            <span class="material-icons-outlined">menu</span>
        </button>
        <div class="mobile-nav-menu" id="mobileNavMenu">
            <a class="nav-link active" href="#" onclick="loadSection('dashboard.html'); closeMobileMenu();">
                <span class="material-icons-outlined">dashboard</span>
                ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
            </a>
            <a class="nav-link" href="#" onclick="loadSection('orders.html'); closeMobileMenu();">
                <span class="material-icons-outlined">receipt_long</span>
                ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
            </a>
            <a class="nav-link" href="#" onclick="loadSection('merchants.html'); closeMobileMenu();">
                <span class="material-icons-outlined">store</span>
                ÿßŸÑÿ™ÿ¨ÿßÿ±
            </a>
            <a class="nav-link" href="#" onclick="loadSection('customers.html'); closeMobileMenu();">
                <span class="material-icons-outlined">people</span>
                ÿßŸÑÿπŸÖŸÑÿßÿ°
            </a>
            <a class="nav-link" href="#" onclick="loadSection('drivers.html'); closeMobileMenu();">
                <span class="material-icons-outlined">local_shipping</span>
                ÿßŸÑÿ≥ÿßÿ¶ŸÇŸàŸÜ
            </a>
            <a class="nav-link" href="#" onclick="loadSection('rewards.html'); closeMobileMenu();">
                <span class="material-icons-outlined">redeem</span>
                ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™
            </a>
            <a class="nav-link" href="#" onclick="loadSection('settings.html'); closeMobileMenu();">
                <span class="material-icons-outlined">settings</span>
                ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™
            </a>
        </div>
    </div>

    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <nav class="col-lg-2 sidebar d-none d-lg-block">
                <ul class="nav flex-column">
                    <li class="nav-item">
                        <a class="nav-link active" href="#" onclick="loadSection('dashboard.html')">
                            <span class="material-icons-outlined me-2">dashboard</span>
                            ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('orders.html')">
                            <span class="material-icons-outlined me-2">receipt_long</span>
                            ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('merchants.html')">
                            <span class="material-icons-outlined me-2">store</span>
                            ÿßŸÑÿ™ÿ¨ÿßÿ±
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('customers.html')">
                            <span class="material-icons-outlined me-2">people</span>
                            ÿßŸÑÿπŸÖŸÑÿßÿ°
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('drivers.html')">
                            <span class="material-icons-outlined me-2">local_shipping</span>
                            ÿßŸÑÿ≥ÿßÿ¶ŸÇŸàŸÜ
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('rewards.html')">
                            <span class="material-icons-outlined me-2">redeem</span>
                            ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™
                        </a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#" onclick="loadSection('settings.html')">
                            <span class="material-icons-outlined me-2">settings</span>
                            ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™
                        </a>
                    </li>
                </ul>
            </nav>
            
            <!-- Main Content -->
            <main class="col-lg-10 ms-auto content-area">
                <iframe id="contentFrame" src="dashboard.html" 
                        style="width: 100%; height: 100vh; border: none;">
                </iframe>
            </main>
        </div>
    </div>

    <script>
        function loadSection(sectionFile) {
            console.log(`Loading section: ${sectionFile}`);
            const iframe = document.getElementById('contentFrame');
            
            // Add loading state
            iframe.classList.add('loading');

            // Add error handling for iframe loading
            iframe.onload = function() {
                console.log(`‚úÖ Successfully loaded: ${sectionFile}`);
                iframe.classList.remove('loading');
            };

            iframe.onerror = function() {
                console.log(`‚ùå Failed to load: ${sectionFile}`);
                iframe.classList.remove('loading');
                // Fallback content
                iframe.src = `data:text/html,<div style="padding:20px;text-align:center;color:#666;">
                    <h3>ÿßŸÑÿµŸÅÿ≠ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©</h3>
                    <p>ÿßŸÑÿµŸÅÿ≠ÿ© ${sectionFile} ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©</p>
                    <button onclick="parent.location.reload()">ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ</button>
                </div>`;
            };

            // Set the source
            iframe.src = sectionFile;

            // Update active nav link for both desktop and mobile
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });

            // Use event.target if available, otherwise find the clicked link
            const clickedLink = event?.target?.closest('a') || 
                                document.querySelector(`[onclick*="${sectionFile}"]`);
            if (clickedLink) {
                clickedLink.classList.add('active');
            }

            // Also update mobile nav links
            document.querySelectorAll('.mobile-nav-menu .nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            const mobileClickedLink = document.querySelector(`.mobile-nav-menu [onclick*="${sectionFile}"]`);
            if (mobileClickedLink) {
                mobileClickedLink.classList.add('active');
            }
        }

        // Mobile menu toggle functions
        function toggleMobileMenu() {
            const menu = document.getElementById('mobileNavMenu');
            const btn = document.querySelector('.mobile-menu-btn .material-icons-outlined');
            
            if (!menu || !btn) {
                console.error('Mobile menu elements not found');
                return;
            }
            
            if (menu.classList.contains('show')) {
                menu.classList.remove('show');
                btn.textContent = 'menu';
                document.body.style.overflow = 'auto';
            } else {
                menu.classList.add('show');
                btn.textContent = 'close';
                document.body.style.overflow = 'hidden';
            }
        }

        function closeMobileMenu() {
            const menu = document.getElementById('mobileNavMenu');
            const btn = document.querySelector('.mobile-menu-btn .material-icons-outlined');
            
            if (menu && btn) {
                menu.classList.remove('show');
                btn.textContent = 'menu';
                document.body.style.overflow = 'auto';
            }
        }

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
            const menu = document.getElementById('mobileNavMenu');
            const btn = document.querySelector('.mobile-menu-btn');
            
            if (menu && menu.classList.contains('show') && 
                !menu.contains(event.target) && 
                !btn.contains(event.target)) {
                closeMobileMenu();
            }
        });

        // Handle window resize for responsive behavior
        function handleResize() {
            const menu = document.getElementById('mobileNavMenu');
            if (window.innerWidth > 991 && menu && menu.classList.contains('show')) {
                closeMobileMenu();
            }
        }

        window.addEventListener('resize', handleResize);

        // Handle orientation change for mobile devices
        window.addEventListener('orientationchange', function() {
            setTimeout(function() {
                handleResize();
                // Adjust iframe height after orientation change
                const iframe = document.getElementById('contentFrame');
                if (iframe) {
                    const isMobile = window.innerWidth <= 991;
                    if (isMobile) {
                        const mobileNavHeight = document.querySelector('.mobile-nav')?.offsetHeight || 70;
                        iframe.style.height = `calc(100vh - ${mobileNavHeight}px)`;
                    }
                }
            }, 100);
        });

        // Initialize responsive iframe height
        function setResponsiveHeight() {
            const iframe = document.getElementById('contentFrame');
            if (iframe && window.innerWidth <= 991) {
                const mobileNavHeight = document.querySelector('.mobile-nav')?.offsetHeight || 70;
                iframe.style.height = `calc(100vh - ${mobileNavHeight}px)`;
            }
        }

        // Test server connectivity on load
        function testServerConnectivity() {
            console.log('üîç Testing server connectivity...');

            // Test if we can reach the current page
            fetch(window.location.href)
                .then(response => {
                    if (response.ok) {
                        console.log('‚úÖ Server is accessible');
                        updateConnectionStatus('server_ok');
                    } else {
                        console.log('‚ö†Ô∏è Server response issues');
                        updateConnectionStatus('server_warning');
                    }
                })
                .catch(error => {
                    console.log('‚ùå Server connectivity issues:', error);
                    updateConnectionStatus('server_error');
                });
        }

        // Enhanced connection status
        function updateConnectionStatus(status) {
            const statusElement = document.createElement('div');
            statusElement.id = 'connection-status';
            statusElement.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                z-index: 9999;
                cursor: pointer;
            `;

            let statusText, bgColor, textColor;

            switch(status) {
                case 'connected':
                    statusText = 'üü¢ Firebase Connected';
                    bgColor = '#d4edda';
                    textColor = '#155724';
                    break;
                case 'server_ok':
                    statusText = 'üü¢ Server Online';
                    bgColor = '#d4edda';
                    textColor = '#155724';
                    break;
                case 'server_warning':
                    statusText = 'üü° Server Issues';
                    bgColor = '#fff3cd';
                    textColor = '#856404';
                    break;
                case 'server_error':
                    statusText = 'üî¥ Server Offline';
                    bgColor = '#f8d7da';
                    textColor = '#721c24';
                    break;
                default: // mock
                    statusText = 'üü° Mock Mode';
                    bgColor = '#fff3cd';
                    textColor = '#856404';
            }

            statusElement.innerHTML = statusText;
            statusElement.style.backgroundColor = bgColor;
            statusElement.style.color = textColor;

            // Add click handler for diagnostics
            statusElement.onclick = function() {
                window.open('test-server.html', '_blank');
            };

            // Remove existing status if any
            const existing = document.getElementById('connection-status');
            if (existing) existing.remove();

            document.body.appendChild(statusElement);
        }

        // Initialize server test on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ Admin panel DOM loaded');
            testServerConnectivity();
            setResponsiveHeight();
            
            // Debug mobile navigation - CRITICAL
            const mobileNav = document.getElementById('mobileNavBar');
            const screenWidth = window.innerWidth;
            console.log(`üì± Screen width: ${screenWidth}px`);
            console.log(`üì± Mobile nav element:`, mobileNav);
            
            if (mobileNav) {
                const computedStyle = window.getComputedStyle(mobileNav);
                console.log(`üì± Mobile nav display:`, computedStyle.display);
                console.log(`üì± Mobile nav visibility:`, computedStyle.visibility);
                console.log(`üì± Mobile nav position:`, computedStyle.position);
                console.log(`üì± Mobile nav z-index:`, computedStyle.zIndex);
                
                // Force visibility for mobile screens
                if (screenWidth <= 991) {
                    console.log('üì± FORCING mobile nav visibility');
                    mobileNav.style.display = 'flex';
                    mobileNav.style.visibility = 'visible';
                    mobileNav.style.opacity = '1';
                    mobileNav.style.position = 'fixed';
                    mobileNav.style.top = '0';
                    mobileNav.style.left = '0';
                    mobileNav.style.right = '0';
                    mobileNav.style.zIndex = '2000';
                    mobileNav.style.background = '#fff';
                    mobileNav.style.borderBottom = '3px solid #1976d2';
                    
                    // Add a test indicator
                    mobileNav.style.outline = '2px solid red';
                    console.log('üì± Added red outline for debugging');
                    
                    setTimeout(() => {
                        mobileNav.style.outline = 'none';
                    }, 3000);
                }
            } else {
                console.error('‚ùå Mobile nav element not found!');
            }
        });

        // If DOMContentLoaded already fired, run immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                testServerConnectivity();
                setResponsiveHeight();
            });
        } else {
            testServerConnectivity();
            setResponsiveHeight();
        }
    </script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-messaging-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-analytics-compat.js"></script>

    <script>
        // Firebase Configuration for Centralized Platform
        const firebaseConfig = {
            apiKey: "AIzaSyBXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
            authDomain: "centralized-delivery-platform.firebaseapp.com", 
            projectId: "centralized-delivery-platform",
            storageBucket: "centralized-delivery-platform.appspot.com",
            messagingSenderId: "123456789012",
            appId: "1:123456789012:web:abcdefghijklmnop",
            measurementId: "G-XXXXXXXXXX"
        };

        // Initialize Firebase
        let db, messaging;
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            
            // Enable offline persistence
            db.enablePersistence()
                .then(() => {
                    console.log('‚úÖ Firestore offline persistence enabled');
                })
                .catch((err) => {
                    if (err.code == 'failed-precondition') {
                        console.log('‚ö†Ô∏è Multiple tabs open, persistence can only be enabled in one tab at a time.');
                    } else if (err.code == 'unimplemented') {
                        console.log('‚ö†Ô∏è The current browser does not support persistence.');
                    }
                });

            // Initialize messaging if supported
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                messaging = firebase.messaging();
                console.log('‚úÖ Firebase messaging initialized');
            } else {
                console.log('‚ö†Ô∏è Push messaging not supported in this browser');
            }

            console.log('üöÄ Firebase initialized successfully');
            
            // Test Firestore connection
            testFirestoreConnection();
            
        } catch (error) {
            console.error('‚ùå Firebase initialization failed:', error);
            
            // Fall back to mock mode
            console.log('üß™ Falling back to mock mode');
            initMockFirebase();
        }

        // Test Firestore connection
        function testFirestoreConnection() {
            db.collection('system_status').add({
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                status: 'admin_panel_connected',
                userAgent: navigator.userAgent,
                source: 'admin_panel'
            })
            .then((docRef) => {
                console.log('‚úÖ Firestore connection test successful. Document ID:', docRef.id);
                initializeRealTimeSystem();
            })
            .catch((error) => {
                console.error('‚ùå Firestore connection test failed:', error);
                initMockFirebase();
            });
        }

        // Initialize real-time system with Firebase
        function initializeRealTimeSystem() {
            console.log('üîÑ Initializing real-time system with Firebase...');
            
            // Set up real-time listeners
            setupFirestoreListeners();
            
            // Initialize order flow manager with Firebase
            window.orderFlowManager = new OrderFlowManager();
            
            // Update UI to show Firebase is connected
            updateConnectionStatus('connected');
        }

        // Set up Firestore real-time listeners
        function setupFirestoreListeners() {
            // Listen to merchants collection
            db.collection('merchants').onSnapshot((snapshot) => {
                console.log('üì° Merchants collection updated');
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        console.log('‚ûï New merchant:', change.doc.data());
                    } else if (change.type === 'modified') {
                        console.log('üìù Modified merchant:', change.doc.data());
                    } else if (change.type === 'removed') {
                        console.log('üóëÔ∏è Removed merchant:', change.doc.data());
                    }
                });
                updateDashboardMetrics('merchants_update', snapshot.docs.length);
            });

            // Listen to orders collection
            db.collection('orders').onSnapshot((snapshot) => {
                console.log('üì° Orders collection updated');
                const orders = snapshot.docs.map(doc => ({id: doc.id, ...doc.data()}));
                updateDashboardMetrics('orders_update', orders);
            });

            // Listen to drivers collection
            db.collection('drivers').onSnapshot((snapshot) => {
                console.log('üì° Drivers collection updated');
                const onlineDrivers = snapshot.docs.filter(doc => doc.data().status === 'online').length;
                updateDashboardMetrics('drivers_update', {
                    total: snapshot.docs.length,
                    online: onlineDrivers
                });
            });

            // Listen to customers collection
            db.collection('customers').onSnapshot((snapshot) => {
                console.log('üì° Customers collection updated');
                updateDashboardMetrics('customers_update', snapshot.docs.length);
            });
        }

        // Mock Firebase for fallback
        function initMockFirebase() {
            db = {
                collection: (name) => ({
                    onSnapshot: (callback) => {
                        console.log(`üß™ Mock: Listening to ${name} collection`);
                        // Simulate initial data
                        setTimeout(() => {
                            callback({
                                docs: [],
                                docChanges: () => []
                            });
                        }, 1000);
                        return () => {}; // Unsubscribe function
                    },
                    add: (data) => {
                        console.log(`üß™ Mock: Adding to ${name}:`, data);
                        return Promise.resolve({ id: 'mock-' + Date.now() });
                    },
                    doc: (id) => ({
                        update: (data) => {
                            console.log(`üß™ Mock: Updating ${name}/${id}:`, data);
                            return Promise.resolve();
                        },
                        get: () => {
                            console.log(`üß™ Mock: Getting ${name}/${id}`);
                            return Promise.resolve({ 
                                exists: true,
                                data: () => ({ id: id, mockData: true })
                            });
                        },
                        set: (data) => {
                            console.log(`üß™ Mock: Setting ${name}/${id}:`, data);
                            return Promise.resolve();
                        }
                    })
                }),
                enablePersistence: () => Promise.resolve()
            };

            messaging = {
                send: (data) => {
                    console.log('üß™ Mock: Sending notification:', data);
                    return Promise.resolve();
                }
            };

            updateConnectionStatus('mock');
            window.orderFlowManager = new OrderFlowManager();
        }

        // Update connection status in UI
        function updateConnectionStatus(status) {
            const statusElement = document.createElement('div');
            statusElement.id = 'connection-status';
            statusElement.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
                z-index: 9999;
            `;
            
            if (status === 'connected') {
                statusElement.innerHTML = 'üü¢ Firebase Connected';
                statusElement.style.backgroundColor = '#d4edda';
                statusElement.style.color = '#155724';
            } else {
                statusElement.innerHTML = 'üü° Mock Mode';
                statusElement.style.backgroundColor = '#fff3cd';
                statusElement.style.color = '#856404';
            }
            
            // Remove existing status if any
            const existing = document.getElementById('connection-status');
            if (existing) existing.remove();
            
            document.body.appendChild(statusElement);
        }

        // Centralized Order Management System
        class OrderFlowManager {
            constructor() {
                this.orders = new Map();
                this.drivers = new Map();
                this.merchants = new Map();
                this.customers = new Map();
                this.initializeRealTimeListeners();
            }

            // Initialize real-time listeners for all collections
            initializeRealTimeListeners() {
                console.log('üîÑ Setting up real-time order flow listeners...');
                
                // Listen to new orders from customer app
                db.collection('orders').onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            this.handleNewOrder(change.doc.data());
                        } else if (change.type === 'modified') {
                            this.handleOrderUpdate(change.doc.data());
                        }
                    });
                });

                // Listen to merchant responses
                db.collection('merchant_responses').onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            this.handleMerchantResponse(change.doc.data());
                        }
                    });
                });

                // Listen to driver responses
                db.collection('driver_responses').onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            this.handleDriverResponse(change.doc.data());
                        }
                    });
                });
            }

            // Step 1: Customer places order
            async handleNewOrder(orderData) {
                console.log('üîî New order received:', orderData);
                
                try {
                    // Update order status to 'processing'
                    await db.collection('orders').doc(orderData.id).update({
                        status: 'processing',
                        processedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        centralSystemReceived: true
                    });

                    // Send order to merchant app
                    await this.sendOrderToMerchant(orderData);

                    // Update dashboard in real-time
                    this.updateDashboard('new_order', orderData);

                } catch (error) {
                    console.error('Error processing new order:', error);
                }
            }

            // Step 2: Send order to merchant app
            async sendOrderToMerchant(orderData) {
                console.log('üì± Sending order to merchant app:', orderData.merchantId);

                try {
                    // Add order to merchant's queue
                    await db.collection('merchant_orders').add({
                        orderId: orderData.id,
                        merchantId: orderData.merchantId,
                        customerInfo: orderData.customer,
                        items: orderData.items,
                        totalAmount: orderData.total,
                        status: 'pending_merchant_confirmation',
                        sentAt: firebase.firestore.FieldValue.serverTimestamp(),
                        timeoutAt: new Date(Date.now() + 10 * 60 * 1000) // 10 minutes timeout
                    });

                    // Send push notification to merchant app
                    await this.sendPushNotification('merchant', orderData.merchantId, {
                        title: 'ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ',
                        body: `ÿ∑ŸÑÿ® ÿ¨ÿØŸäÿØ ŸÖŸÜ ${orderData.customer.name} - ${orderData.total} ÿ±.ÿ≥`,
                        data: {
                            type: 'new_order',
                            orderId: orderData.id,
                            action_required: 'confirm_or_reject'
                        }
                    });

                    console.log('‚úÖ Order sent to merchant successfully');

                } catch (error) {
                    console.error('Error sending order to merchant:', error);
                }
            }

            // Step 3: Handle merchant response (confirm/reject)
            async handleMerchantResponse(responseData) {
                console.log('üè™ Merchant response received:', responseData);

                try {
                    if (responseData.action === 'confirm') {
                        // Update order status
                        await db.collection('orders').doc(responseData.orderId).update({
                            status: 'confirmed_by_merchant',
                            merchantConfirmedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            estimatedPrepTime: responseData.prepTime || 15
                        });

                        // Notify customer about confirmation
                        await this.notifyCustomer(responseData.orderId, 'order_confirmed', {
                            message: 'ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿ∑ŸÑÿ®ŸÉ ŸÖŸÜ ÿßŸÑÿ™ÿßÿ¨ÿ±',
                            estimatedTime: responseData.prepTime
                        });

                        // Start driver selection process
                        await this.initiateDriverSelection(responseData.orderId);

                    } else if (responseData.action === 'reject') {
                        // Update order status
                        await db.collection('orders').doc(responseData.orderId).update({
                            status: 'rejected_by_merchant',
                            merchantRejectedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            rejectionReason: responseData.reason
                        });

                        // Notify customer about rejection
                        await this.notifyCustomer(responseData.orderId, 'order_rejected', {
                            message: 'ÿπÿ∞ÿ±ÿßŸãÿå ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿ∑ŸÑÿ®ŸÉ ŸÖŸÜ ÿßŸÑÿ™ÿßÿ¨ÿ±',
                            reason: responseData.reason
                        });
                    }

                    this.updateDashboard('merchant_response', responseData);

                } catch (error) {
                    console.error('Error handling merchant response:', error);
                }
            }

            // Step 4: Optimized driver selection algorithm
            async initiateDriverSelection(orderId) {
                console.log('üöö Starting driver selection for order:', orderId);

                try {
                    // Get order details
                    const orderDoc = await db.collection('orders').doc(orderId).get();
                    const orderData = orderDoc.data();

                    // Get available drivers near merchant location
                    const nearbyDrivers = await this.findOptimalDrivers(
                        orderData.merchant.location,
                        orderData.customer.location
                    );

                    if (nearbyDrivers.length === 0) {
                        await this.handleNoDriversAvailable(orderId);
                        return;
                    }

                    // Update order status
                    await db.collection('orders').doc(orderId).update({
                        status: 'searching_for_driver',
                        driverSearchStarted: firebase.firestore.FieldValue.serverTimestamp(),
                        candidateDrivers: nearbyDrivers.map(d => d.id)
                    });

                    // Send notifications to selected drivers simultaneously
                    await this.notifyMultipleDrivers(orderId, nearbyDrivers);

                    // Set timeout for driver selection
                    setTimeout(() => {
                        this.checkDriverSelectionTimeout(orderId);
                    }, 5 * 60 * 1000); // 5 minutes timeout

                } catch (error) {
                    console.error('Error initiating driver selection:', error);
                }
            }

            // Advanced driver selection algorithm
            async findOptimalDrivers(merchantLocation, customerLocation) {
                try {
                    // Get all available drivers
                    const driversSnapshot = await db.collection('drivers')
                        .where('status', '==', 'available')
                        .where('isOnline', '==', true)
                        .get();

                    const drivers = [];
                    
                    driversSnapshot.forEach(doc => {
                        const driver = { id: doc.id, ...doc.data() };
                        
                        // Calculate distances
                        const distanceToMerchant = this.calculateDistance(
                            driver.currentLocation, 
                            merchantLocation
                        );
                        const distanceToCustomer = this.calculateDistance(
                            merchantLocation, 
                            customerLocation
                        );

                        // Calculate score based on multiple factors
                        const score = this.calculateDriverScore(driver, distanceToMerchant, distanceToCustomer);

                        drivers.push({
                            ...driver,
                            distanceToMerchant,
                            distanceToCustomer,
                            totalDistance: distanceToMerchant + distanceToCustomer,
                            score
                        });
                    });

                    // Sort by score (higher is better) and return top 5
                    return drivers
                        .sort((a, b) => b.score - a.score)
                        .slice(0, 5);

                } catch (error) {
                    console.error('Error finding optimal drivers:', error);
                    return [];
                }
            }

            // Driver scoring algorithm
            calculateDriverScore(driver, distanceToMerchant, distanceToCustomer) {
                let score = 100; // Base score

                // Distance factor (closer is better)
                score -= (distanceToMerchant * 2); // Distance to merchant is more important
                score -= distanceToCustomer;

                // Rating factor
                score += (driver.rating || 4.0) * 10;

                // Completion rate factor
                score += (driver.completionRate || 0.9) * 20;

                // Response time factor (faster response gets higher score)
                score += (1 / (driver.averageResponseTime || 60)) * 100;

                // Vehicle type factor
                if (driver.vehicleType === 'motorcycle') score += 15;
                if (driver.vehicleType === 'bicycle') score += 10;
                if (driver.vehicleType === 'car') score += 5;

                return Math.max(0, score);
            }

            // Send notifications to multiple drivers simultaneously
            async notifyMultipleDrivers(orderId, drivers) {
                console.log(`üì± Notifying ${drivers.length} drivers for order:`, orderId);

                const notifications = drivers.map(driver => 
                    this.sendPushNotification('driver', driver.id, {
                        title: 'ÿ∑ŸÑÿ® ÿ™ŸàÿµŸäŸÑ ÿ¨ÿØŸäÿØ',
                        body: `ÿ∑ŸÑÿ® ÿ™ŸàÿµŸäŸÑ ŸÖÿ™ÿßÿ≠ - ÿßŸÑŸÖÿ≥ÿßŸÅÿ©: ${driver.distanceToMerchant.toFixed(1)} ŸÉŸÖ`,
                        data: {
                            type: 'delivery_request',
                            orderId: orderId,
                            estimatedDistance: driver.totalDistance,
                            estimatedEarnings: this.calculateEstimatedEarnings(driver.totalDistance),
                            action_required: 'accept_or_reject'
                        }
                    })
                );

                try {
                    await Promise.all(notifications);
                    console.log('‚úÖ All driver notifications sent successfully');
                } catch (error) {
                    console.error('Error sending driver notifications:', error);
                }
            }

            // Step 5: Handle driver responses
            async handleDriverResponse(responseData) {
                console.log('üöó Driver response received:', responseData);

                try {
                    if (responseData.action === 'accept') {
                        // Check if order is still available
                        const orderDoc = await db.collection('orders').doc(responseData.orderId).get();
                        const orderData = orderDoc.data();

                        if (orderData.status !== 'searching_for_driver') {
                            // Order already assigned to another driver
                            await this.notifyDriver(responseData.driverId, 'order_no_longer_available');
                            return;
                        }

                        // Assign driver to order
                        await db.collection('orders').doc(responseData.orderId).update({
                            status: 'driver_assigned',
                            assignedDriver: responseData.driverId,
                            driverAssignedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });

                        // Update driver status
                        await db.collection('drivers').doc(responseData.driverId).update({
                            status: 'busy',
                            currentOrder: responseData.orderId
                        });

                        // Notify customer about driver assignment
                        await this.notifyCustomer(responseData.orderId, 'driver_assigned', {
                            driverInfo: await this.getDriverInfo(responseData.driverId)
                        });

                        // Cancel notifications for other drivers
                        await this.cancelOtherDriverNotifications(responseData.orderId, responseData.driverId);

                        console.log('‚úÖ Driver assigned successfully');

                    } else if (responseData.action === 'reject') {
                        // Log rejection for analytics
                        await db.collection('driver_rejections').add({
                            driverId: responseData.driverId,
                            orderId: responseData.orderId,
                            reason: responseData.reason,
                            rejectedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    }

                    this.updateDashboard('driver_response', responseData);

                } catch (error) {
                    console.error('Error handling driver response:', error);
                }
            }

            // Utility functions
            calculateDistance(point1, point2) {
                const R = 6371; // Earth's radius in km
                const dLat = (point2.lat - point1.lat) * Math.PI / 180;
                const dLon = (point2.lng - point1.lng) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(point1.lat * Math.PI / 180) * Math.cos(point2.lat * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                return R * c;
            }

            calculateEstimatedEarnings(distance) {
                const baseRate = 5; // Base rate in SAR
                const perKmRate = 2; // Rate per km in SAR
                return baseRate + (distance * perKmRate);
            }

            async sendPushNotification(appType, userId, notificationData) {
                if (!messaging) {
                    console.log('üì± Messaging not available, logging notification:', notificationData);
                    return Promise.resolve();
                }

                const topic = `${appType}_${userId}`;
                
                try {
                    return await messaging.send({
                        topic: topic,
                        notification: {
                            title: notificationData.title,
                            body: notificationData.body
                        },
                        data: notificationData.data,
                        android: {
                            priority: 'high',
                            notification: {
                                sound: 'default',
                                priority: 'high'
                            }
                        },
                        apns: {
                            payload: {
                                aps: {
                                    sound: 'default',
                                    priority: 10
                                }
                            }
                        }
                    });
                } catch (error) {
                    console.error('‚ùå Error sending notification:', error);
                    return Promise.resolve();
                }
            }

            async handleOrderUpdate(orderData) {
                console.log('üìù Order updated:', orderData);
                this.updateDashboard('order_update', orderData);
            }

            // Real-time dashboard updates
            updateDashboard(eventType, data) {
                const event = new CustomEvent('orderSystemUpdate', {
                    detail: { type: eventType, data: data }
                });
                document.dispatchEvent(event);
            }

            async notifyCustomer(orderId, type, data) {
                console.log(`üì± Notifying customer for order ${orderId}:`, type, data);
                // Add to customer notifications collection
                try {
                    await db.collection('customer_notifications').add({
                        orderId: orderId,
                        type: type,
                        data: data,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: false
                    });
                } catch (error) {
                    console.log('Mock notification sent:', type, data);
                }
            }

            async notifyDriver(driverId, type, data) {
                console.log(`üì± Notifying driver ${driverId}:`, type, data);
                // Add to driver notifications collection
                try {
                    await db.collection('driver_notifications').add({
                        driverId: driverId,
                        type: type,
                        data: data,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        read: false
                    });
                } catch (error) {
                    console.log('Mock notification sent:', type, data);
                }
            }

            async getDriverInfo(driverId) {
                try {
                    const driverDoc = await db.collection('drivers').doc(driverId).get();
                    if (driverDoc.exists) {
                        return driverDoc.data();
                    } else {
                        return { id: driverId, name: 'Driver', mockData: true };
                    }
                } catch (error) {
                    console.log('Mock driver info returned');
                    return { id: driverId, name: 'Driver', mockData: true };
                }
            }

            async cancelOtherDriverNotifications(orderId, assignedDriverId) {
                console.log(`üö´ Canceling notifications for order ${orderId}, assigned to ${assignedDriverId}`);
                try {
                    // Update other driver notifications as cancelled
                    const batch = db.batch();
                    const notificationsSnapshot = await db.collection('driver_notifications')
                        .where('data.orderId', '==', orderId)
                        .where('driverId', '!=', assignedDriverId)
                        .get();
                    
                    notificationsSnapshot.docs.forEach(doc => {
                        batch.update(doc.ref, { cancelled: true });
                    });
                    
                    await batch.commit();
                } catch (error) {
                    console.log('Mock: Other driver notifications cancelled');
                }
            }

            async handleNoDriversAvailable(orderId) {
                console.log(`‚ö†Ô∏è No drivers available for order ${orderId}`);
                try {
                    await db.collection('orders').doc(orderId).update({
                        status: 'no_drivers_available',
                        noDriversAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Notify customer about no drivers
                    await this.notifyCustomer(orderId, 'no_drivers_available', {
                        message: 'ÿπÿ∞ÿ±ÿßŸãÿå ŸÑÿß ŸäŸàÿ¨ÿØ ÿ≥ÿßÿ¶ŸÇŸàŸÜ ŸÖÿ™ÿßÿ≠ŸàŸÜ ÿ≠ÿßŸÑŸäÿßŸã. ÿ≥ŸÜÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≥ÿßÿ¶ŸÇ ÿ¢ÿÆÿ± ŸÇÿ±Ÿäÿ®ÿßŸã.'
                    });
                } catch (error) {
                    console.log('Mock: Order marked as no drivers available');
                }
            }

            checkDriverSelectionTimeout(orderId) {
                console.log(`‚è∞ Checking driver selection timeout for order ${orderId}`);
                // Check if order is still searching for driver
                db.collection('orders').doc(orderId).get()
                    .then(doc => {
                        if (doc.exists && doc.data().status === 'searching_for_driver') {
                            console.log(`‚è∞ Driver selection timeout for order ${orderId}`);
                            this.handleNoDriversAvailable(orderId);
                        }
                    })
                    .catch(error => {
                        console.log('Mock: Driver selection timeout checked');
                    });
            }
        }

        // Update dashboard metrics
        function updateDashboardMetrics(type, data) {
            console.log('üìä Updating dashboard metrics:', type, data);
            
            // Dispatch event for real-time updates
            const event = new CustomEvent('orderSystemUpdate', {
                detail: { type: type, data: data }
            });
            document.dispatchEvent(event);
        }

        // Listen for real-time updates
        document.addEventListener('orderSystemUpdate', (event) => {
            const { type, data } = event.detail;
            console.log('üìà Dashboard update received:', type, data);
            
            // Update UI elements based on the update type
            switch(type) {
                case 'merchants_update':
                    console.log('Updating merchant count:', data);
                    break;
                case 'orders_update':
                    console.log('Updating order metrics:', data);
                    break;
                case 'drivers_update':
                    console.log('Updating driver statistics:', data);
                    break;
                case 'customers_update':
                    console.log('Updating customer count:', data);
                    break;
                case 'new_order':
                    console.log('New order received:', data);
                    break;
                case 'merchant_response':
                    console.log('Merchant response:', data);
                    break;
                case 'driver_response':
                    console.log('Driver response:', data);
                    break;
            }
        });

        // Error handling for iframe loading
        document.getElementById('contentFrame').addEventListener('error', function() {
            console.log('‚ö†Ô∏è Failed to load page in iframe');
            this.src = 'data:text/html,<div style="padding:20px;text-align:center;"><h3>ÿßŸÑÿµŸÅÿ≠ÿ© ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©</h3><p>ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿµŸÅÿ≠ÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©</p></div>';
        });

        console.log('üöÄ Centralized Delivery Platform admin panel loaded');
    </script>
</body>
</html>
